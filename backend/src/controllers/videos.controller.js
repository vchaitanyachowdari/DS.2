const { supabase } = require('../config/database');
const { AppError, asyncHandler } = require('../middleware/errorHandler');
const { validationResult } = require('express-validator');

/**
 * @route   GET /api/videos
 * @desc    Get all videos with optional filtering and pagination
 * @access  Public (but shows bookmark status if authenticated)
 * @query   category, search, page, limit
 */
const getAllVideos = asyncHandler(async (req, res) => {
  const { category, search, page = 1, limit = 24 } = req.query;
  const userId = req.userId; // May be null if not authenticated

  // Calculate pagination
  const offset = (parseInt(page) - 1) * parseInt(limit);

  // Build query - only return AI-generated videos
  let query = supabase
    .from('videos')
    .select('*', { count: 'exact' })
    .eq('is_generated', true)
    .order('created_at', { ascending: false });

  // Filter by category if provided
  if (category && category !== 'All') {
    query = query.eq('category', category);
  }

  // Search in title and description if provided
  if (search && search.trim()) {
    query = query.or(`title.ilike.%${search}%,description.ilike.%${search}%`);
  }

  // Apply pagination
  query = query.range(offset, offset + parseInt(limit) - 1);

  // Execute query
  const { data: videos, error, count } = await query;

  if (error) {
    console.error('Error fetching videos:', error);
    throw new AppError('Failed to fetch videos', 500);
  }

  // If user is authenticated, check which videos are bookmarked
  let videosWithBookmarks = videos;
  if (userId) {
    const { data: bookmarks } = await supabase
      .from('bookmarks')
      .select('video_id')
      .eq('user_id', userId);

    const bookmarkedIds = new Set(bookmarks?.map(b => b.video_id) || []);

    videosWithBookmarks = videos.map(video => ({
      ...video,
      isBookmarked: bookmarkedIds.has(video.id)
    }));
  } else {
    videosWithBookmarks = videos.map(video => ({
      ...video,
      isBookmarked: false
    }));
  }

  res.status(200).json({
    success: true,
    data: {
      videos: videosWithBookmarks,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: count,
        totalPages: Math.ceil(count / parseInt(limit))
      }
    }
  });
});

/**
 * @route   GET /api/videos/search
 * @desc    Search videos by query
 * @access  Public
 * @query   q (search query), category
 */
const searchVideos = asyncHandler(async (req, res) => {
  const { q, category } = req.query;
  const userId = req.userId;

  if (!q || !q.trim()) {
    throw new AppError('Search query is required', 400);
  }

  // Build search query - only search AI-generated videos
  let query = supabase
    .from('videos')
    .select('*')
    .eq('is_generated', true)
    .or(`title.ilike.%${q}%,description.ilike.%${q}%`)
    .order('views', { ascending: false })
    .limit(20);

  // Filter by category if provided
  if (category && category !== 'All') {
    query = query.eq('category', category);
  }

  const { data: videos, error } = await query;

  if (error) {
    console.error('Error searching videos:', error);
    throw new AppError('Failed to search videos', 500);
  }

  // Add bookmark status if authenticated
  let videosWithBookmarks = videos;
  if (userId) {
    const { data: bookmarks } = await supabase
      .from('bookmarks')
      .select('video_id')
      .eq('user_id', userId);

    const bookmarkedIds = new Set(bookmarks?.map(b => b.video_id) || []);
    videosWithBookmarks = videos.map(video => ({
      ...video,
      isBookmarked: bookmarkedIds.has(video.id)
    }));
  }

  res.status(200).json({
    success: true,
    data: {
      videos: videosWithBookmarks,
      count: videos.length,
      query: q
    }
  });
});

/**
 * @route   GET /api/videos/my-videos
 * @desc    Get videos generated by the authenticated user
 * @access  Private
 */
const getMyVideos = asyncHandler(async (req, res) => {
  const userId = req.userId;

  // Get user's generated videos
  const { data: videos, error } = await supabase
    .from('videos')
    .select('*')
    .eq('created_by', userId)
    .eq('is_generated', true)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching user videos:', error);
    throw new AppError('Failed to fetch your videos', 500);
  }

  // Add generation job status for each video
  const videoIds = videos.map(v => v.id);
  const { data: jobs } = await supabase
    .from('video_generation_jobs')
    .select('video_id, status, progress')
    .in('video_id', videoIds);

  const jobsByVideoId = {};
  jobs?.forEach(job => {
    jobsByVideoId[job.video_id] = {
      status: job.status,
      progress: job.progress
    };
  });

  const videosWithStatus = videos.map(video => ({
    ...video,
    isBookmarked: true, // User's own videos are considered bookmarked
    generationStatus: jobsByVideoId[video.id] || { status: 'completed' }
  }));

  res.status(200).json({
    success: true,
    data: {
      videos: videosWithStatus,
      count: videos.length
    }
  });
});

/**
 * @route   GET /api/videos/bookmarks
 * @desc    Get user's bookmarked videos
 * @access  Private
 */
const getBookmarkedVideos = asyncHandler(async (req, res) => {
  const userId = req.userId;

  // Get bookmarked videos with video details
  const { data: bookmarks, error } = await supabase
    .from('bookmarks')
    .select(`
      video_id,
      created_at,
      videos (*)
    `)
    .eq('user_id', userId)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching bookmarks:', error);
    throw new AppError('Failed to fetch bookmarked videos', 500);
  }

  // Transform the response
  const videos = bookmarks.map(bookmark => ({
    ...bookmark.videos,
    isBookmarked: true,
    bookmarkedAt: bookmark.created_at
  }));

  res.status(200).json({
    success: true,
    data: {
      videos,
      count: videos.length
    }
  });
});

/**
 * @route   GET /api/videos/:id
 * @desc    Get a single video by ID
 * @access  Public (bookmark status if authenticated)
 */
const getVideoById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const userId = req.userId;

  // Get video
  const { data: video, error } = await supabase
    .from('videos')
    .select('*')
    .eq('id', id)
    .single();

  if (error || !video) {
    throw new AppError('Video not found', 404);
  }

  // Check if bookmarked
  let isBookmarked = false;
  if (userId) {
    const { data: bookmark } = await supabase
      .from('bookmarks')
      .select('id')
      .eq('user_id', userId)
      .eq('video_id', id)
      .single();

    isBookmarked = !!bookmark;
  }

  res.status(200).json({
    success: true,
    data: {
      video: {
        ...video,
        isBookmarked
      }
    }
  });
});

/**
 * @route   POST /api/videos/:id/bookmark
 * @desc    Bookmark a video
 * @access  Private
 */
const bookmarkVideo = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const userId = req.userId;

  // Check if video exists
  const { data: video, error: videoError } = await supabase
    .from('videos')
    .select('id')
    .eq('id', id)
    .single();

  if (videoError || !video) {
    throw new AppError('Video not found', 404);
  }

  // Check if already bookmarked
  const { data: existingBookmark } = await supabase
    .from('bookmarks')
    .select('id')
    .eq('user_id', userId)
    .eq('video_id', id)
    .single();

  if (existingBookmark) {
    return res.status(200).json({
      success: true,
      message: 'Video already bookmarked'
    });
  }

  // Create bookmark
  const { error: bookmarkError } = await supabase
    .from('bookmarks')
    .insert([
      {
        user_id: userId,
        video_id: id
      }
    ]);

  if (bookmarkError) {
    console.error('Error creating bookmark:', bookmarkError);
    throw new AppError('Failed to bookmark video', 500);
  }

  // Increment bookmarks_count in user_stats
  const { data: stats } = await supabase
    .from('user_stats')
    .select('bookmarks_count')
    .eq('user_id', userId)
    .single();

  if (stats) {
    await supabase
      .from('user_stats')
      .update({ bookmarks_count: stats.bookmarks_count + 1 })
      .eq('user_id', userId);
  }

  res.status(201).json({
    success: true,
    message: 'Video bookmarked successfully'
  });
});

/**
 * @route   DELETE /api/videos/:id/bookmark
 * @desc    Remove bookmark from a video
 * @access  Private
 */
const removeBookmark = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const userId = req.userId;

  // Delete bookmark
  const { error } = await supabase
    .from('bookmarks')
    .delete()
    .eq('user_id', userId)
    .eq('video_id', id);

  if (error) {
    console.error('Error removing bookmark:', error);
    throw new AppError('Failed to remove bookmark', 500);
  }

  // Decrement bookmarks_count in user_stats
  const { data: stats } = await supabase
    .from('user_stats')
    .select('bookmarks_count')
    .eq('user_id', userId)
    .single();

  if (stats && stats.bookmarks_count > 0) {
    await supabase
      .from('user_stats')
      .update({ bookmarks_count: stats.bookmarks_count - 1 })
      .eq('user_id', userId);
  }

  res.status(200).json({
    success: true,
    message: 'Bookmark removed successfully'
  });
});

/**
 * @route   POST /api/videos/:id/view
 * @desc    Increment view count for a video
 * @access  Public
 */
const incrementView = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const userId = req.userId;
  const { watchDuration } = req.body; // Duration watched in seconds (optional)

  // Increment view count
  const { data: video, error } = await supabase
    .from('videos')
    .select('views')
    .eq('id', id)
    .single();

  if (error || !video) {
    throw new AppError('Video not found', 404);
  }

  // Update views
  await supabase
    .from('videos')
    .update({ views: video.views + 1 })
    .eq('id', id);

  // If authenticated, create view history entry
  if (userId) {
    await supabase
      .from('view_history')
      .insert([
        {
          user_id: userId,
          video_id: id,
          watch_duration: watchDuration || 0
        }
      ]);

    // Update user stats
    const { data: stats } = await supabase
      .from('user_stats')
      .select('videos_watched')
      .eq('user_id', userId)
      .single();

    if (stats) {
      await supabase
        .from('user_stats')
        .update({ videos_watched: stats.videos_watched + 1 })
        .eq('user_id', userId);
    }
  }

  res.status(200).json({
    success: true,
    data: {
      views: video.views + 1
    }
  });
});

module.exports = {
  getAllVideos,
  searchVideos,
  getMyVideos,
  getBookmarkedVideos,
  getVideoById,
  bookmarkVideo,
  removeBookmark,
  incrementView
};
